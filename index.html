<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>晶片微影製程模擬器 - 光罩與微影</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f0f4f8;
        }
        canvas {
            background: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 8px;
            cursor: crosshair;
        }
        .step-card {
            transition: all 0.3s ease;
        }
        .step-card.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
            transform: scale(1.02);
        }
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: all 0.2s;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        .btn-primary:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Header -->
    <header class="text-center mb-8 max-w-2xl">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-3">晶片導線建造模擬器</h1>
        <p class="text-gray-600">
            並非所有電晶體都需要工作。透過微影製程的圖案設計，我們可以決定哪些要連起來。
            <br>
            <span class="text-purple-600 font-semibold">本次更新：版面調整，模擬畫布移至頂部。</span>
        </p>
    </header>

    <!-- Main Content Grid: Visualization on the left (2/3), Controls on the right (1/3) -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 w-full max-w-6xl">
        
        <!-- 1. Visualization Canvas (Always first in HTML, top on mobile, left on desktop) -->
        <div class="lg:col-span-2 flex flex-col items-center bg-gray-100 rounded-xl p-4 shadow-inner">
            <div class="relative w-full aspect-[4/3] max-w-[800px]">
                <canvas id="simCanvas" class="w-full h-full block"></canvas>
            </div>
            <div class="mt-4 flex gap-4 text-sm text-gray-600 font-medium">
                <div class="flex items-center"><span class="w-3 h-3 bg-gray-700 rounded-full mr-1"></span> 矽基底</div>
                <div class="flex items-center"><span class="w-3 h-3 bg-blue-100 border border-blue-300 rounded-full mr-1"></span> 絕緣層(高透光)</div>
                <div class="flex items-center"><span class="w-3 h-3 bg-purple-500 rounded-full mr-1"></span> 光罩擋光區</div>
            </div>
        </div>

        <!-- 2. Controls & Explanation (Always second in HTML, bottom on mobile, right on desktop) -->
        <div class="lg:col-span-1 space-y-4">
            
            <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                    <span class="bg-blue-100 text-blue-600 py-1 px-3 rounded-full text-sm mr-2">步驟 <span id="step-number">0</span></span>
                    當前狀態與操作
                </h3>
                <div id="instruction-text" class="text-gray-700 min-h-[80px]">
                    準備開始。底部有三個電晶體。為了製造特定邏輯閘，我們計畫只連接左邊兩個，右邊那個將不會有任何導線連接。
                </div>
                
                <div class="mt-6 flex flex-col gap-3">
                    <button id="action-btn" onclick="nextStep()" class="btn-primary w-full text-white font-bold py-3 px-6 rounded-lg shadow-xl flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd" />
                        </svg>
                        <span id="btn-text">開始第一層製程</span>
                    </button>
                    
                    <button onclick="resetSim()" class="text-gray-500 hover:text-red-500 text-sm py-2 underline transition-colors">
                        重置所有層數
                    </button>
                </div>
            </div>

            <!-- Process Indicators -->
            <div class="space-y-2">
                <div id="step-indicator-1" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">1. 沉積絕緣層 (Deposition)</div>
                    <div class="text-xs text-gray-500">覆蓋高透明度的二氧化矽，保護底層。</div>
                </div>
                <div id="step-indicator-2" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">2. 微影曝光 (Lithography)</div>
                    <div class="text-xs text-gray-500">光罩擋住不需要的地方，UV光照射要挖洞的區域。</div>
                </div>
                <div id="step-indicator-3" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">3. 電鍍金屬 (Metal Fill)</div>
                    <div class="text-xs text-gray-500">填入銅。金屬會形成一條「橋」，把左邊兩個連起來。</div>
                </div>
                <div id="step-indicator-4" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">4. 化學機械研磨 (CMP)</div>
                    <div class="text-xs text-gray-500">磨平表面，線路完成。</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Simulation Logic
         */
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let animationId;
        
        // State
        const STATE = {
            IDLE: 'idle',
            DEPOSITING: 'depositing',
            ETCHING: 'etching', // Now represents Lithography + Etch
            FILLING: 'filling',
            POLISHING: 'polishing'
        };

        // Configuration
        const config = {
            layerHeight: 60,
            baseHeight: 100,
            transistorWidth: 80,
            animSpeed: 0.015,
            maskY: 40 // Height of the mask from top
        };

        // Data Model
        let layers = []; // Array of completed layers
        let currentLayer = {
            type: 'contact', // contact, m1, via1, m2, via2, etc.
            progress: 0,
            state: STATE.IDLE,
            dielectricOpacity: 0,
            etchProgress: 0,
            fillProgress: 0,
            polishProgress: 0
        };

        // Simulation Step Tracker (0 to 4 cyclic)
        let processStep = 0; 
        let globalLayerIndex = 0; // Which floor are we on?

        // Resize handler
        function resize() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2; // Retina support
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            width = rect.width;
            height = rect.height;
            draw();
        }
        window.addEventListener('resize', resize);

        // --- Core Geometry Logic ---
        function getFeatureGeometry(type, spacing) {
            // Define active transistors (only 1 and 2)
            const activeIndices = [1, 2];
            
            if (type === 'contact' || type.startsWith('via')) {
                // Vertical Plugs: Return array of rects
                return activeIndices.map(i => ({
                    x: spacing * i - 8,
                    w: 16
                }));
            } else {
                // Metal Lines: Return a single wide rect connecting T1 and T2
                // Start from T1-20 to T2+20
                const x1 = spacing * activeIndices[0] - 20;
                const x2 = spacing * activeIndices[activeIndices.length-1] + 20;
                return [{
                    x: x1,
                    w: x2 - x1
                }];
            }
        }

        // --- Drawing Functions ---

        function drawBase() {
            const bottomY = height - 20;
            
            // Silicon Substrate
            const grad = ctx.createLinearGradient(0, bottomY - config.baseHeight, 0, bottomY);
            grad.addColorStop(0, '#475569');
            grad.addColorStop(1, '#1e293b');
            ctx.fillStyle = grad;
            ctx.fillRect(0, bottomY - config.baseHeight, width, config.baseHeight);
            
            // Draw Transistors (Source/Drain/Gate)
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);

            for(let i=1; i<=transistorCount; i++) {
                const centerX = spacing * i;
                const groundY = bottomY - config.baseHeight;
                
                const isActive = i <= 2;
                
                // Source/Drain (Green)
                ctx.fillStyle = isActive ? '#22c55e' : '#86efac';
                ctx.fillRect(centerX - 40, groundY, 25, 15); // Left
                ctx.fillRect(centerX + 15, groundY, 25, 15); // Right
                
                // Gate Oxide (Yellow thin line)
                ctx.fillStyle = '#facc15';
                ctx.fillRect(centerX - 10, groundY - 2, 20, 2);

                // Poly Gate (Red)
                ctx.fillStyle = isActive ? '#ef4444' : '#fca5a5';
                ctx.fillRect(centerX - 10, groundY - 22, 20, 20);

                // Spacers (Grey)
                ctx.fillStyle = '#94a3b8';
                ctx.beginPath();
                ctx.moveTo(centerX - 10, groundY - 22);
                ctx.lineTo(centerX - 15, groundY);
                ctx.lineTo(centerX - 10, groundY);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(centerX + 10, groundY - 22);
                ctx.lineTo(centerX + 15, groundY);
                ctx.lineTo(centerX + 10, groundY);
                ctx.fill();
            }

            // Label
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("FEOL (底層電晶體)", width/2, bottomY - 10);
        }

        function drawDielectric(yPos, opacity) {
            // Updated opacity logic: Max opacity is 0.4 to keep it transparent like glass
            // This ensures transistors are always visible
            const maxOpacity = 0.4; 
            const currentOpacity = opacity * maxOpacity;

            ctx.fillStyle = `rgba(219, 234, 254, ${currentOpacity})`; // Very clear blue glass
            ctx.fillRect(0, yPos - config.layerHeight, width, config.layerHeight);
            
            // Border (more subtle)
            if (opacity > 0.5) {
                ctx.strokeStyle = `rgba(147, 197, 253, ${opacity * 0.6})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(0, yPos - config.layerHeight, width, config.layerHeight);
            }
        }

        function drawMetal(yPos, fillLevel, type, isPolished) {
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);
            const features = getFeatureGeometry(type, spacing);

            ctx.save();
            ctx.beginPath();
            
            features.forEach(f => {
                ctx.rect(f.x, yPos - config.layerHeight, f.w, config.layerHeight);
            });
            
            ctx.clip();
            
            // Draw Copper Texture
            const metalTopY = yPos - (config.layerHeight * fillLevel);
            const grad = ctx.createLinearGradient(0, yPos - config.layerHeight, 0, yPos);
            grad.addColorStop(0, '#f97316'); // Orange
            grad.addColorStop(0.5, '#fed7aa'); // Light Orange highlight
            grad.addColorStop(1, '#c2410c'); // Dark Orange
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, metalTopY, width, config.layerHeight * fillLevel);
            
            ctx.restore();
        }
        
        function drawEtchedHoles(yPos, progress, type) {
            ctx.globalCompositeOperation = 'destination-out';
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);
            const depth = config.layerHeight * progress;
            const features = getFeatureGeometry(type, spacing);

            features.forEach(f => {
                ctx.fillRect(f.x, yPos - config.layerHeight, f.w, depth);
            });
            
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawPhotomaskAndUV(yPos, type) {
            // 1. Draw UV Light Beams (Purple/Violet)
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);
            const features = getFeatureGeometry(type, spacing);

            ctx.save();
            
            // Beam glow effect
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 10;
            ctx.fillStyle = 'rgba(168, 85, 247, 0.4)'; // Purple UV light

            features.forEach(f => {
                // Beam from top to wafer surface
                ctx.fillRect(f.x, 0, f.w, yPos - config.layerHeight);
            });
            ctx.restore();

            // 2. Draw Photomask (The plate holding the pattern)
            const maskY = 50;
            const maskHeight = 10;
            
            // Glass substrate of the mask (Transparent)
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.fillRect(0, maskY, width, maskHeight);
            ctx.strokeStyle = '#94a3b8';
            ctx.strokeRect(0, maskY, width, maskHeight);

            // Chrome Patterns (The blocking parts)
            // We need to draw chrome EVERYWHERE EXCEPT where the features are
            ctx.fillStyle = '#1e293b'; // Dark Chrome material
            
            // Draw a full rect, then "cut out" the features? 
            // Canvas doesn't easily support "inverse" fill in one go without complex paths.
            // Approach: Draw rectangles between features.
            
            let currentX = 0;
            // Sort features by x to be safe
            features.sort((a,b) => a.x - b.x);

            features.forEach(f => {
                // Draw chrome from previous X to start of feature
                if (f.x > currentX) {
                    ctx.fillRect(currentX, maskY, f.x - currentX, maskHeight);
                }
                currentX = f.x + f.w;
            });
            
            // Draw remaining chrome to right edge
            if (currentX < width) {
                ctx.fillRect(currentX, maskY, width - currentX, maskHeight);
            }

            // Label for Mask
            ctx.fillStyle = '#64748b';
            ctx.font = '10px sans-serif';
            ctx.fillText("光罩 (Photomask)", 10, maskY - 5);
        }
        
        function drawOverburden(yPos, progress) {
            const overburdenHeight = 20 * progress; 
            const grad = ctx.createLinearGradient(0, yPos - config.layerHeight - overburdenHeight, 0, yPos - config.layerHeight);
            grad.addColorStop(0, '#f97316');
            grad.addColorStop(1, '#c2410c');
            ctx.fillStyle = grad;
            ctx.fillRect(0, yPos - config.layerHeight - overburdenHeight, width, overburdenHeight);
        }

        function drawCMPMechanism(yPos) {
            const padY = yPos - config.layerHeight - 5;
            const x = (Date.now() / 5) % (width + 100) - 50; 
            
            ctx.fillStyle = '#cbd5e1'; 
            ctx.fillRect(x, padY - 20, 100, 20);
            ctx.strokeStyle = '#64748b';
            ctx.strokeRect(x, padY - 20, 100, 20);
            
            if (Math.random() > 0.5) {
                ctx.fillStyle = '#fef08a';
                ctx.beginPath();
                ctx.arc(x + 50 + (Math.random()*20-10), padY, 2, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // --- Main Render Loop ---

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // 1. Base
            drawBase();

            let currentY = height - 20 - config.baseHeight;

            // 2. Draw Finished Layers
            layers.forEach(layer => {
                drawDielectric(currentY, 1);
                drawEtchedHoles(currentY, 1, layer.type);
                drawMetal(currentY, 1, layer.type, true);
                currentY -= config.layerHeight;
            });

            // 3. Draw Active Layer (The one being built)
            if (currentLayer.state !== STATE.IDLE) {
                
                // Step A: Dielectric
                if (currentLayer.dielectricOpacity > 0) {
                    drawDielectric(currentY, currentLayer.dielectricOpacity);
                }

                // Step B: Etching (Now includes Mask and UV)
                if (currentLayer.state === STATE.ETCHING) {
                    // Draw Mask and UV Beams BEFORE etching holes fully completes visual
                    drawPhotomaskAndUV(currentY, currentLayer.type);
                    
                    if (currentLayer.etchProgress > 0) {
                        drawEtchedHoles(currentY, currentLayer.etchProgress, currentLayer.type);
                    }
                } else if (currentLayer.etchProgress > 0) {
                     // If etching is done but we are in next steps, keep holes visible
                     drawEtchedHoles(currentY, currentLayer.etchProgress, currentLayer.type);
                }

                // Step C: Filling
                if (currentLayer.fillProgress > 0) {
                    drawMetal(currentY, currentLayer.fillProgress, currentLayer.type, false);
                    if (currentLayer.fillProgress > 0.8) {
                        const obProgress = (currentLayer.fillProgress - 0.8) * 5; 
                        drawOverburden(currentY, obProgress);
                    }
                }

                // Step D: Polishing
                if (currentLayer.polishProgress > 0) {
                     const remainingOverburden = 1 - currentLayer.polishProgress;
                     if (remainingOverburden > 0) {
                         drawOverburden(currentY, remainingOverburden);
                         drawCMPMechanism(currentY);
                     }
                }
            }
        }

        // --- Interaction Logic ---

        function updateUI() {
            document.querySelectorAll('.step-card').forEach(el => el.classList.remove('active'));
            if (processStep > 0 && processStep <= 4) {
                document.getElementById(`step-indicator-${processStep}`).classList.add('active');
            }
            
            document.getElementById('step-number').innerText = processStep;

            const instructions = {
                0: "準備開始下一層製程。注意看第三個電晶體（右側），它將會被「掩埋」而沒有接線。",
                1: "【沉積】二氧化矽(玻璃)覆蓋了所有東西。為了讓您看清楚底下的電晶體，這裡將絕緣層顯示為高透明度。",
                2: "【微影曝光】注意看上方出現的「光罩」！它擋住了紫色的UV光，只讓光線照在我們想挖洞的地方。被照到的地方變軟，隨後被蝕刻掉。",
                3: "【電鍍】銅填滿了我們挖的通道。因為挖的洞是連通的（在金屬層），這兩個電晶體現在電性相連了。",
                4: "【研磨 CMP】磨掉表面多餘的銅。現在你可以清楚看到，電路只存在於左側，右側完全絕緣。"
            };
            
            const btnTexts = {
                0: "開始沉積絕緣層",
                1: "放置光罩並曝光",
                2: "注入金屬連通",
                3: "開始CMP研磨",
                4: "完成此層"
            };

            document.getElementById('instruction-text').innerText = instructions[processStep];
            document.getElementById('btn-text').innerText = btnTexts[processStep];
        }

        function nextStep() {
            const btn = document.getElementById('action-btn');
            btn.disabled = true;

            if (processStep === 0) {
                currentLayer = {
                    type: globalLayerIndex === 0 ? 'contact' : (globalLayerIndex % 2 === 0 ? 'via'+(globalLayerIndex/2) : 'm'+Math.ceil(globalLayerIndex/2)),
                    progress: 0,
                    state: STATE.IDLE,
                    dielectricOpacity: 0,
                    etchProgress: 0,
                    fillProgress: 0,
                    polishProgress: 0
                };
                processStep = 1;
                runAnimation(STATE.DEPOSITING);
            } else if (processStep === 1) {
                processStep = 2;
                runAnimation(STATE.ETCHING);
            } else if (processStep === 2) {
                processStep = 3;
                runAnimation(STATE.FILLING);
            } else if (processStep === 3) {
                processStep = 4;
                runAnimation(STATE.POLISHING);
            } else if (processStep === 4) {
                layers.push({...currentLayer});
                globalLayerIndex++;
                currentLayer.state = STATE.IDLE;
                processStep = 0;
                btn.disabled = false;
                updateUI();
                draw(); 
            }
        }

        function runAnimation(type) {
            currentLayer.state = type;
            let progress = 0;
            updateUI();

            function loop() {
                progress += config.animSpeed;
                if (progress > 1) progress = 1;

                if (type === STATE.DEPOSITING) currentLayer.dielectricOpacity = progress;
                if (type === STATE.ETCHING) currentLayer.etchProgress = progress;
                if (type === STATE.FILLING) currentLayer.fillProgress = progress;
                if (type === STATE.POLISHING) currentLayer.polishProgress = progress;

                draw();

                if (progress < 1) {
                    animationId = requestAnimationFrame(loop);
                } else {
                    document.getElementById('action-btn').disabled = false;
                    if (processStep === 4) {
                        document.getElementById('btn-text').innerText = "完成此層";
                    }
                }
            }
            loop();
        }

        function resetSim() {
            layers = [];
            globalLayerIndex = 0;
            processStep = 0;
            currentLayer = {
                type: 'contact',
                state: STATE.IDLE,
                dielectricOpacity: 0,
                etchProgress: 0,
                fillProgress: 0,
                polishProgress: 0
            };
            draw();
            updateUI();
            document.getElementById('action-btn').disabled = false;
        }

        // Init
        resize();
        updateUI();

    </script>
</body>
</html>
