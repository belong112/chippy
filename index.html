<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>晶片導線製程模擬器 - 光罩與微影</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f0f4f8;
        }
        canvas {
            background: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 8px;
            cursor: crosshair;
        }
        .step-card {
            transition: all 0.3s ease;
        }
        .step-card.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
            transform: scale(1.02);
        }
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: all 0.2s;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        .btn-primary:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Header -->
    <header class="text-center mb-8 max-w-2xl">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-3">晶片導線建造模擬器</h1>
        <p class="text-gray-600">
            並非所有電晶體都需要工作。透過微影製程的圖案設計，我們可以決定哪些要連起來。
            <br>
            <span class="text-purple-600 font-semibold">本次更新：已修正步驟 6 完成後凹槽消失的錯誤。</span>
        </p>
    </header>

    <!-- Main Content Grid: Visualization on the left (2/3), Controls on the right (1/3) -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 w-full max-w-6xl">
        
        <!-- 1. Visualization Canvas (Always first in HTML, top on mobile, left on desktop) -->
        <div class="lg:col-span-2 flex flex-col items-center bg-gray-100 rounded-xl p-4 shadow-inner">
            <div class="relative w-full aspect-[4/3] max-w-[800px]">
                <canvas id="simCanvas" class="w-full h-full block"></canvas>
            </div>
            <div class="mt-4 flex gap-4 text-sm text-gray-600 font-medium">
                <div class="flex items-center"><span class="w-3 h-3 bg-gray-700 rounded-full mr-1"></span> 矽基底</div>
                <div class="flex items-center"><span class="w-3 h-3 bg-blue-100 border border-blue-300 rounded-full mr-1"></span> 絕緣層(高透光)</div>
                <div class="flex items-center"><span class="w-3 h-3 bg-orange-500 rounded-full mr-1"></span> 光阻劑層</div>
            </div>
        </div>

        <!-- 2. Controls & Explanation (Always second in HTML, bottom on mobile, right on desktop) -->
        <div class="lg:col-span-1 space-y-4">
            
            <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                    <span class="bg-blue-100 text-blue-600 py-1 px-3 rounded-full text-sm mr-2">步驟 <span id="step-number">0</span></span>
                    當前狀態與操作
                </h3>
                <div id="instruction-text" class="text-gray-700 min-h-[80px]">
                    準備開始。底部有三個電晶體。為了製造特定邏輯閘，我們計畫只連接左邊兩個，右邊那個將不會有任何導線連接。
                </div>
                
                <div class="mt-6 flex flex-col gap-3">
                    <button id="action-btn" onclick="nextStep()" class="btn-primary w-full text-white font-bold py-3 px-6 rounded-lg shadow-xl flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd" />
                        </svg>
                        <span id="btn-text">開始第一層製程</span>
                    </button>
                    
                    <button onclick="resetSim()" class="text-gray-500 hover:text-red-500 text-sm py-2 underline transition-colors">
                        重置所有層數
                    </button>
                </div>
            </div>

            <!-- Process Indicators - Updated to 8 steps -->
            <div class="space-y-2">
                <div id="step-indicator-1" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">1. 沉積絕緣層 (Deposition)</div>
                    <div class="text-xs text-gray-500">覆蓋高透明度的二氧化矽。</div>
                </div>
                <div id="step-indicator-2" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">2. 塗布光阻劑 (Photoresist Apply)</div>
                    <div class="text-xs text-gray-500">旋塗一層感光材料。</div>
                </div>
                <div id="step-indicator-3" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">3. 微影：曝光 (Exposure)</div>
                    <div class="text-xs text-gray-500">UV光短暫照射後消失。圖案已形成在光阻劑中。</div>
                </div>
                <div id="step-indicator-4" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">4. 顯影 (Develop)</div>
                    <div class="text-xs text-gray-500">移除被曝光的光阻劑，**未曝光的部分保留**，露出絕緣層表面。</div>
                </div>
                <div id="step-indicator-5" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">5. 乾蝕刻 (Dry Etch)</div>
                    <div class="text-xs text-gray-500">電漿蝕刻掉露出的絕緣層，形成通道。</div>
                </div>
                <div id="step-indicator-6" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">6. 光阻去除 (Photoresist Strip)</div>
                    <div class="text-xs text-gray-500">徹底移除剩餘的光阻劑保護層。</div>
                </div>
                <div id="step-indicator-7" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">7. 電鍍金屬 (Metal Fill)</div>
                    <div class="text-xs text-gray-500">填入銅，形成導線與多餘的銅層。</div>
                </div>
                <div id="step-indicator-8" class="step-card border-l-4 border-gray-200 bg-white p-3 rounded shadow-sm">
                    <div class="font-bold text-sm text-gray-800">8. 化學機械研磨 (CMP)</div>
                    <div class="text-xs text-gray-500">磨平表面，線路完成。</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Simulation Logic
         */
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let animationId;
        
        // State
        const STATE = {
            IDLE: 'idle',
            DEPOSITING: 'depositing',
            PR_APPLY: 'pr_apply', 
            DEVELOPING: 'developing',   // Step 3: UV Exposure, PR remains
            PR_REMOVE: 'pr_remove',     // Step 4: Develop (Patterning)
            DIELECTRIC_ETCH: 'dielectric_etch', // Step 5: Dry Etch
            PR_STRIP: 'pr_strip',       // Step 6: PR Strip 
            FILLING: 'filling',         // Step 7: Metal Fill
            POLISHING: 'polishing'      // Step 8: CMP
        };

        // Configuration
        const config = {
            layerHeight: 60,
            prHeight: 10, 
            baseHeight: 100,
            transistorWidth: 80,
            animSpeed: 0.015,
            maskY: 40 // Height of the mask from top
        };

        // Data Model
        let layers = []; // Array of completed layers
        let currentLayer = {
            type: 'contact', // contact, m1, via1, m2, via2, etc.
            progress: 0,
            state: STATE.IDLE,
            dielectricOpacity: 0,
            photoresistOpacity: 0, 
            etchProgress: 0,
            fillProgress: 0,
            polishProgress: 0
        };

        // Simulation Step Tracker (0 to 8 cyclic)
        let processStep = 0; 
        let globalLayerIndex = 0; // Which floor are we on?

        // Resize handler
        function resize() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2; // Retina support
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            width = rect.width;
            height = rect.height;
            draw();
        }
        window.addEventListener('resize', resize);

        // --- Core Geometry Logic ---
        function getFeatureGeometry(type, spacing) {
            // Define active transistors (only 1 and 2)
            const activeIndices = [1, 2];
            
            if (type === 'contact' || type.startsWith('via')) {
                // Vertical Plugs: Return array of rects
                return activeIndices.map(i => ({
                    x: spacing * i - 8,
                    w: 16
                }));
            } else {
                // Metal Lines: Return a single wide rect connecting T1 and T2
                // Start from T1-20 to T2+20
                const x1 = spacing * activeIndices[0] - 20;
                const x2 = spacing * activeIndices[activeIndices.length-1] + 20;
                return [{
                    x: x1,
                    w: x2 - x1
                }];
            }
        }

        // --- Drawing Functions ---

        function drawBase() {
            const bottomY = height - 20;
            
            // Silicon Substrate
            const grad = ctx.createLinearGradient(0, bottomY - config.baseHeight, 0, bottomY);
            grad.addColorStop(0, '#475569');
            grad.addColorStop(1, '#1e293b');
            ctx.fillStyle = grad;
            ctx.fillRect(0, bottomY - config.baseHeight, width, config.baseHeight);
            
            // Draw Transistors (Source/Drain/Gate)
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);

            for(let i=1; i<=transistorCount; i++) {
                const centerX = spacing * i;
                const groundY = bottomY - config.baseHeight;
                
                const isActive = i <= 2;
                
                // Source/Drain (Green)
                ctx.fillStyle = isActive ? '#22c55e' : '#86efac';
                ctx.fillRect(centerX - 40, groundY, 25, 15); // Left
                ctx.fillRect(centerX + 15, groundY, 25, 15); // Right
                
                // Gate Oxide (Yellow thin line)
                ctx.fillStyle = '#facc15';
                ctx.fillRect(centerX - 10, groundY - 2, 20, 2);

                // Poly Gate (Red)
                ctx.fillStyle = isActive ? '#ef4444' : '#fca5a5';
                ctx.fillRect(centerX - 10, groundY - 22, 20, 20);

                // Spacers (Grey)
                ctx.fillStyle = '#94a3b8';
                ctx.beginPath();
                ctx.moveTo(centerX - 10, groundY - 22);
                ctx.lineTo(centerX - 15, groundY);
                ctx.lineTo(centerX - 10, groundY);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(centerX + 10, groundY - 22);
                ctx.lineTo(centerX + 15, groundY);
                ctx.lineTo(centerX + 10, groundY);
                ctx.fill();
            }

            // Label
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("FEOL (底層電晶體)", width/2, bottomY - 10);
        }

        function drawDielectric(yPos, opacity) {
            // Max opacity is 0.4 to keep it transparent like glass
            const maxOpacity = 0.4; 
            const currentOpacity = opacity * maxOpacity;

            ctx.fillStyle = `rgba(219, 234, 254, ${currentOpacity})`; // Very clear blue glass
            ctx.fillRect(0, yPos - config.layerHeight, width, config.layerHeight);
            
            // Border (more subtle)
            if (opacity > 0.5) {
                ctx.strokeStyle = `rgba(147, 197, 253, ${opacity * 0.6})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(0, yPos - config.layerHeight, width, config.layerHeight);
            }
        }
        
        // Updated drawPhotoresist to handle patterning and stripping
        function drawPhotoresist(yPos, opacity, patternProgress) {
            const prHeight = config.prHeight;
            const topY = yPos - config.layerHeight; // Top of dielectric
            
            // 1. Draw the full block of PR first (using the current opacity)
            ctx.fillStyle = `rgba(249, 115, 22, ${opacity})`; // Orange color for PR
            ctx.fillRect(0, topY - prHeight, width, prHeight);
            
            // 2. Cut out the exposed/developed areas (Patterning)
            if (patternProgress > 0) {
                const transistorCount = 3;
                const spacing = width / (transistorCount + 1);
                const features = getFeatureGeometry(currentLayer.type, spacing);
                
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'white'; // Color doesn't matter for destination-out
                
                features.forEach(f => {
                    // Cut out the area where the PR should be removed (exposed area)
                    // The height of the cutout animates from 0 to full PR height (prHeight)
                    const cutoutHeight = prHeight * patternProgress;
                    ctx.fillRect(f.x, topY - cutoutHeight, f.w, cutoutHeight);
                });
                ctx.restore();
            }
            
            // 3. Border 
            if (opacity > 0.5) {
                ctx.strokeStyle = `rgba(234, 88, 12, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(0, topY - prHeight, width, prHeight);
            }
        }

        function drawMetal(yPos, fillLevel, type, isPolished) {
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);
            const features = getFeatureGeometry(type, spacing);

            ctx.save();
            ctx.beginPath();
            
            features.forEach(f => {
                ctx.rect(f.x, yPos - config.layerHeight, f.w, config.layerHeight);
            });
            
            ctx.clip(); // 裁剪到凹槽區域
            
            // Draw Copper Texture
            const metalTopY = yPos - (config.layerHeight * fillLevel);
            const grad = ctx.createLinearGradient(0, yPos - config.layerHeight, 0, yPos);
            grad.addColorStop(0, '#f97316'); // Orange
            grad.addColorStop(0.5, '#fed7aa'); // Light Orange highlight
            grad.addColorStop(1, '#c2410c'); // Dark Orange
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, metalTopY, width, config.layerHeight * fillLevel);
            
            ctx.restore();
        }
        
        function drawEtchedHoles(yPos, progress, type) {
            ctx.globalCompositeOperation = 'destination-out';
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);
            // The depth is now based on the full dielectric layer height
            const depth = config.layerHeight * progress; 
            const features = getFeatureGeometry(type, spacing);

            features.forEach(f => {
                // Ensure the cutout starts from the top of the dielectric layer
                ctx.fillRect(f.x, yPos - config.layerHeight, f.w, depth);
            });
            
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawPhotomaskAndUV(yPos, type) {
            // 1. Draw UV Light Beams (Purple/Violet)
            const transistorCount = 3;
            const spacing = width / (transistorCount + 1);
            const features = getFeatureGeometry(type, spacing);

            ctx.save();
            
            // Beam glow effect
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 10;
            ctx.fillStyle = 'rgba(168, 85, 247, 0.4)'; // Purple UV light

            features.forEach(f => {
                // Beam from top to PR surface (yPos is top of PR)
                ctx.fillRect(f.x, 0, f.w, yPos);
            });
            ctx.restore();

            // 2. Draw Photomask (The plate holding the pattern)
            const maskY = 50;
            const maskHeight = 10;
            
            // Glass substrate of the mask (Transparent)
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.fillRect(0, maskY, width, maskHeight);
            ctx.strokeStyle = '#94a3b8';
            ctx.strokeRect(0, maskY, width, maskHeight);

            // Chrome Patterns (The blocking parts)
            ctx.fillStyle = '#1e293b'; // Dark Chrome material
            
            let currentX = 0;
            features.sort((a,b) => a.x - b.x);

            features.forEach(f => {
                // Draw chrome from previous X to start of feature
                if (f.x > currentX) {
                    ctx.fillRect(currentX, maskY, f.x - currentX, maskHeight);
                }
                currentX = f.x + f.w;
            });
            
            // Draw remaining chrome to right edge
            if (currentX < width) {
                ctx.fillRect(currentX, maskY, width - currentX, maskHeight);
            }

            // Label for Mask
            ctx.fillStyle = '#64748b';
            ctx.font = '10px sans-serif';
            ctx.fillText("光罩 (Photomask)", 10, maskY - 5);
        }
        
        function drawOverburden(yPos, progress) {
            const overburdenHeight = 20 * progress; 
            const topY = yPos - config.layerHeight; // Top of dielectric/metal
            const grad = ctx.createLinearGradient(0, topY - overburdenHeight, 0, topY);
            grad.addColorStop(0, '#f97316');
            grad.addColorStop(1, '#c2410c');
            ctx.fillStyle = grad;
            ctx.fillRect(0, topY - overburdenHeight, width, overburdenHeight);
        }

        function drawCMPMechanism(yPos) {
            const topY = yPos - config.layerHeight;
            const padY = topY - 5;
            // Animation for the pad moving left and right
            const x = (Date.now() / 5) % (width + 100) - 50; 
            
            ctx.fillStyle = '#cbd5e1'; 
            ctx.fillRect(x, padY - 20, 100, 20);
            ctx.strokeStyle = '#64748b';
            ctx.strokeRect(x, padY - 20, 100, 20);
            
            // Slurry particle visualization
            if (Math.random() > 0.5) {
                ctx.fillStyle = '#fef08a';
                ctx.beginPath();
                ctx.arc(x + 50 + (Math.random()*20-10), padY, 2, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // --- Main Render Loop ---

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // 1. Base
            drawBase();

            let currentY = height - 20 - config.baseHeight;

            // 2. Draw Finished Layers
            layers.forEach(layer => {
                drawDielectric(currentY, 1);
                drawEtchedHoles(currentY, 1, layer.type);
                drawMetal(currentY, 1, layer.type, true);
                currentY -= config.layerHeight;
            });

            // 3. Draw Active Layer (The one being built)
            if (currentLayer.state !== STATE.IDLE) {
                let currentTop = currentY - config.layerHeight; // Top of Dielectric

                // 3.1. Dielectric (Base Layer)
                if (currentLayer.dielectricOpacity > 0) {
                    drawDielectric(currentY, currentLayer.dielectricOpacity);
                }

                // 3.2. Etching visualization (Cut the hole out of the dielectric)
                // 必須放在 Dielectric 之後，PR 之前
                if (currentLayer.etchProgress > 0) {
                    drawEtchedHoles(currentY, currentLayer.etchProgress, currentLayer.type);
                } 
                
                // 3.3. Photoresist (Above Dielectric) 
                // 只在 photoresistOpacity > 0 時繪製，避免 destination-out 邏輯在 PR 移除後仍產生副作用
                if (currentLayer.photoresistOpacity > 0) {
                    if (currentLayer.state === STATE.PR_APPLY || currentLayer.state === STATE.DEPOSITING) {
                        drawPhotoresist(currentY, currentLayer.photoresistOpacity, 0); // Full unpatterned PR
                    } else if (currentLayer.state === STATE.DEVELOPING) {
                        let topOfPRLayer = currentTop - config.prHeight;
                        drawPhotomaskAndUV(topOfPRLayer, currentLayer.type); // Draw UV/Mask
                        drawPhotoresist(currentY, 1, 0); // Full PR, UV exposed (but not yet developed)
                    } else if (currentLayer.state === STATE.PR_REMOVE) {
                        // Step 4: Developing (PR removed in exposed area)
                        drawPhotoresist(currentY, 1, currentLayer.progress); // Animate the patterning/removal
                    } else if (currentLayer.state === STATE.DIELECTRIC_ETCH) {
                        drawPhotoresist(currentY, 1, 1); // Fully patterned PR remains for protection
                    } else if (currentLayer.state === STATE.PR_STRIP) {
                        // Step 6: PR Strip (remaining PR is removed)
                        drawPhotoresist(currentY, 1 - currentLayer.progress, 1); // Animate full PR layer disappearance
                    }
                }

                // --- 3.4. Metal Filling and Polishing Logic ---
                let metalFillLevel = 0;
                
                // **嚴格防護**：金屬只在步驟 7 (填充) 或 8 (研磨) 時才可能被繪製。
                const shouldBeMetalProcess = processStep >= 7; 
                const holeIsReady = currentLayer.etchProgress === 1;

                if (shouldBeMetalProcess) {
                    // 判斷金屬填充量 (僅在明確的填充或研磨狀態下進行)
                    if (currentLayer.state === STATE.FILLING) {
                        metalFillLevel = currentLayer.fillProgress;
                    } else if (currentLayer.state === STATE.POLISHING) {
                        metalFillLevel = 1; // Trench is full during polishing
                    } else if (processStep === 8 || (processStep === 0 && layers.length > 0)) {
                        // 最終狀態或已完成層，視為滿填
                        metalFillLevel = 1;
                    }
                }

                // 1. Draw Metal Trench Fill
                // 只有當孔洞挖好 (etchProgress=1) 且金屬填充量 > 0 且在金屬製程步驟 (>=7) 時才繪製。
                if (holeIsReady && metalFillLevel > 0 && shouldBeMetalProcess) { 
                    const isPolished = currentLayer.state === STATE.POLISHING && currentLayer.polishProgress === 1;
                    drawMetal(currentY, metalFillLevel, currentLayer.type, isPolished);
                }
                
                // 2. Draw Overburden & CMP Mechanism (只在金屬已填充時才需考慮)
                if (shouldBeMetalProcess && metalFillLevel > 0) {
                    if (currentLayer.state === STATE.FILLING) {
                        // Overburden grows during filling phase (from 0.8 to 1.0)
                        if (currentLayer.fillProgress > 0.8) {
                            const obProgress = (currentLayer.fillProgress - 0.8) * 5; 
                            drawOverburden(currentY, obProgress);
                        }
                    } else if (currentLayer.state === STATE.POLISHING) {
                        // Overburden shrinks during polishing phase
                        const remainingOverburden = 1 - currentLayer.polishProgress;
                        if (remainingOverburden > 0) {
                            drawOverburden(currentY, remainingOverburden);
                            drawCMPMechanism(currentY);
                        }
                    } else if (currentLayer.fillProgress === 1 && currentLayer.etchProgress === 1 && processStep < 8) {
                        // Filling is done, waiting for polish: show full overburden (Between step 7 finish and step 8 start)
                        drawOverburden(currentY, 1);
                    }
                }
            }
        }

        // --- Interaction Logic ---

        function updateUI() {
            document.querySelectorAll('.step-card').forEach(el => el.classList.remove('active'));
            // Highlight the indicator corresponding to the *result* of the completed action (processStep 1-8)
            if (processStep > 0 && processStep <= 8) { 
                document.getElementById(`step-indicator-${processStep}`).classList.add('active');
            }
            
            document.getElementById('step-number').innerText = processStep;

            const instructions = {
                0: "準備開始下一層製程。注意看第三個電晶體（右側），它將會被「掩埋」而沒有接線。",
                1: "【沉積】二氧化矽(玻璃)覆蓋了所有東西。為了讓您看清楚底下的電晶體，這裡將絕緣層顯示為高透明度。",
                2: "【塗布光阻劑】在絕緣層上旋塗一層感光材料（正型光阻），這是用來定義圖形的關鍵。",
                3: "【微影：曝光】光罩對準，UV光短暫照射。光阻劑內部圖案已形成，等待顯影液移除(顯影)。請點擊下一步進行顯影。",
                4: "【顯影】使用顯影液移除被曝光的光阻劑，**未曝光的部分將保留**以做為保護罩。此時絕緣層的開口已形成。",
                5: "【乾蝕刻】使用電漿蝕刻掉露出的絕緣層，形成導線通道。上方的光阻劑保護了未曝光區域。",
                6: "【光阻去除】使用濕法或乾法徹底移除剩餘的光阻劑，只留下絕緣層上的通道。",
                7: "【電鍍】銅填滿了我們挖的通道，並在表面形成多餘的銅層 (Overburden)。",
                8: "【研磨 CMP】磨掉表面多餘的銅。現在你可以清楚看到，電路只存在於左側，右側完全絕緣。"
            };
            
            const btnTexts = {
                0: "開始沉積絕緣層",
                1: "塗布光阻劑",
                2: "放置光罩並曝光", // Triggers DEVELOPING (Step 3)
                3: "顯影光阻劑", // Triggers PR_REMOVE (Step 4)
                4: "乾蝕刻絕緣層", // Triggers DIELECTRIC_ETCH (Step 5)
                5: "光阻去除 (Strip)", // Triggers PR_STRIP (Step 6)
                6: "注入金屬連通", // Triggers FILLING (Step 7)
                7: "研磨平坦化 (CMP)", // Triggers POLISHING (Step 8)
                8: "完成此層" // Triggers loop to 0
            };

            let currentBtnText = btnTexts[processStep] || "下一步";

            // Dynamic status while animation is running
            if (document.getElementById('action-btn').disabled) {
                 if (currentLayer.state === STATE.DEVELOPING) {
                     currentBtnText = "曝光中...";
                 } else if (currentLayer.state === STATE.PR_REMOVE) {
                     currentBtnText = "顯影中 (光阻劑圖案形成)...";
                 } else if (currentLayer.state === STATE.DIELECTRIC_ETCH) {
                     currentBtnText = "絕緣層蝕刻中...";
                 } else if (currentLayer.state === STATE.PR_STRIP) {
                     currentBtnText = "移除剩餘光阻劑...";
                 } else if (currentLayer.state === STATE.FILLING) {
                     currentBtnText = "電鍍填充中...";
                 } else if (currentLayer.state === STATE.POLISHING) {
                     currentBtnText = "研磨平坦化中...";
                 } else {
                     currentBtnText = "處理中...";
                 }
            }


            document.getElementById('instruction-text').innerText = instructions[processStep] || instructions[0]; // Fallback instruction
            document.getElementById('btn-text').innerText = currentBtnText;
        }

        function nextStep() {
            const btn = document.getElementById('action-btn');
            btn.disabled = true;

            if (processStep === 0) {
                currentLayer = {
                    type: globalLayerIndex === 0 ? 'contact' : (globalLayerIndex % 2 === 0 ? 'via'+(globalLayerIndex/2) : 'm'+Math.ceil(globalLayerIndex/2)),
                    progress: 0,
                    state: STATE.IDLE,
                    dielectricOpacity: 0,
                    photoresistOpacity: 0,
                    etchProgress: 0,
                    fillProgress: 0,
                    polishProgress: 0
                };
                processStep = 1;
                runAnimation(STATE.DEPOSITING);
            } else if (processStep === 1) {
                processStep = 2; 
                runAnimation(STATE.PR_APPLY);
            } else if (processStep === 2) {
                // Step 3: DEVELOPING (UV Exposure)
                processStep = 3; 
                currentLayer.dielectricOpacity = 1; 
                currentLayer.photoresistOpacity = 1; // PR is now fully applied
                runAnimation(STATE.DEVELOPING);
            } else if (processStep === 3) {
                // Step 4: PR_REMOVE (Develop - Patterning)
                processStep = 4;
                runAnimation(STATE.PR_REMOVE);
            } else if (processStep === 4) {
                // Step 5: DIELECTRIC_ETCH (Dry Etch)
                processStep = 5;
                runAnimation(STATE.DIELECTRIC_ETCH);
            } else if (processStep === 5) {
                // Step 6: PR_STRIP (Photoresist Strip)
                processStep = 6;
                currentLayer.etchProgress = 1; // Ensure hole is fully formed before strip
                runAnimation(STATE.PR_STRIP);
            } else if (processStep === 6) {
                // Step 7: FILLING (Metal Fill)
                processStep = 7; 
                runAnimation(STATE.FILLING);
            } else if (processStep === 7) {
                // Step 8: POLISHING (CMP)
                processStep = 8; 
                runAnimation(STATE.POLISHING);
            } else if (processStep === 8) {
                // Loop back to 0
                layers.push({...currentLayer});
                globalLayerIndex++;
                currentLayer.state = STATE.IDLE;
                processStep = 0;
                btn.disabled = false;
                updateUI();
                draw(); 
            }
        }

        function runAnimation(type) {
            currentLayer.state = type;
            let progress = 0;
            const ANIM_SPEED = config.animSpeed;
            
            updateUI(); // Update UI to show "Processing..." immediately

            function loop() {
                progress += ANIM_SPEED;
                if (progress > 1) progress = 1;
                
                // --- Update Data Based on State ---
                currentLayer.progress = progress; // Generic progress for all steps

                if (type === STATE.DEPOSITING) currentLayer.dielectricOpacity = progress;
                if (type === STATE.PR_APPLY) currentLayer.photoresistOpacity = progress;
                
                if (type === STATE.DEVELOPING) {
                    // Step 3 (Exposure): Only UV/Mask animation
                    currentLayer.photoresistOpacity = 1; 
                }

                if (type === STATE.PR_REMOVE) { // Step 4 (Develop)
                    // Patterning is handled visually in drawPhotoresist via progress
                }
                
                if (type === STATE.DIELECTRIC_ETCH) { // Step 5 (Dry Etch)
                    currentLayer.etchProgress = progress; // Etch progresses
                }

                if (type === STATE.PR_STRIP) { // Step 6 (PR Strip)
                    // Strip is handled visually in drawPhotoresist via progress (1-progress)
                }
                
                if (type === STATE.FILLING) currentLayer.fillProgress = progress;
                if (type === STATE.POLISHING) currentLayer.polishProgress = progress;
                // --- End Update Data ---

                draw();

                if (progress < 1) {
                    animationId = requestAnimationFrame(loop);
                } else {
                    document.getElementById('action-btn').disabled = false;
                    
                    // Final state adjustments for visual clarity
                    if (type === STATE.PR_REMOVE) {
                        currentLayer.progress = 1; // Patterning complete
                    }
                    if (type === STATE.DIELECTRIC_ETCH) {
                        currentLayer.etchProgress = 1; // Hole definitely formed
                    }
                    if (type === STATE.PR_STRIP) {
                        currentLayer.progress = 1; // Strip complete
                        // **修正：明確設定光阻劑透明度為 0，確保 PR 繪圖邏輯停止運行**
                        currentLayer.photoresistOpacity = 0; 
                    }
                    if (type === STATE.POLISHING) {
                        currentLayer.polishProgress = 1; // Final cleanup
                    }

                    updateUI();
                }
            }
            loop();
        }

        function resetSim() {
            layers = [];
            globalLayerIndex = 0;
            processStep = 0;
            currentLayer = {
                type: 'contact',
                state: STATE.IDLE,
                dielectricOpacity: 0,
                photoresistOpacity: 0,
                etchProgress: 0,
                fillProgress: 0,
                polishProgress: 0
            };
            draw();
            updateUI();
            document.getElementById('action-btn').disabled = false;
        }

        // Init
        resize();
        updateUI();

    </script>
</body>
</html>
